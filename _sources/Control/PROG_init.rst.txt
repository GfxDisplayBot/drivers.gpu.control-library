


.. _Initialization-programming-guide:

API Initialization
-------------------
Applications need to include the "igcl_api.h" header file in the applications project. All application developers are encouraged to include the "cApiWrapper.cpp" file . The wrapper file abstracts the code for dynamic loading of the library along with the function pointer creation.

Any application which needs to communicate with the Intel Graphics Hardware needs to use the Intel Graphics Control Libray to enumerate the available Intel Graphics Adapters on the system.
Each of the enumerated adapters will have a unique handle and the applications can use the unique handle to call the api.The adapter handle parameter of the API ensures that the api is targeted to the correct adapter.

The pseudo code below shows how to initialize the IGCL library and enumerate the adapters:

.. parsed-literal::

   function main( ... )
    :ref:`ctl-init-args-t` CtlInitArgs;
    ctl_api_handle_t hAPIHandle;
       if (:ref:`ctlInit`\(CtlInitArgs, &hAPIHandle) != :ref:`CTL_RESULT_SUCCESS <ctl-result-t>`\)
           output("Can't initialize the API")
       else
           # Enumerate all adapters
           ctl_device_adapter_handle_t \*hDevices = nullptr;
           uint32_t Adapter_count = 0;
           :ref:`ctlEnumerateDevices`\(hAPIHandle,&Adapter_count, hDevices);
           hDevices = (ctl_device_adapter_handle_t \*)malloc(sizeof(ctl_device_adapter_handle_t) \* Adapter_count);
           :ref:`ctlEnumerateDevices`\(hAPIHandle,&Adapter_count, hDevices);
           
           #Use the handle to call the api's
           
           for(index = 0 .. Adapter_count-1)
               # Get Adapter Properties
               :ref:`ctl-device-adapter-properties-t` StDeviceAdapterProperties = { 0 };
			   
               #OS specific initialization.This is an Windows example
			   
               StDeviceAdapterProperties.Size           = sizeof(:ref:`ctl-device-adapter-properties-t`\);
               StDeviceAdapterProperties.pDeviceID      = malloc(sizeof(LUID));
               StDeviceAdapterProperties.device_id_size = sizeof(LUID);
               :ref:`ctlGetDeviceProperties`\(hDevices[Index], &StDeviceAdapterProperties);
			   
              
    free_memory(...)

Using Level Zero
-----------------
IGCL provide an API to retrieve level zero handle for a given device adapter.
Following C++ code shows how to do the same.

.. parsed-literal::

    #include "ze_ddi.h" // to call Level zero directly
    ctl_result_t Level0HandleTest(ctl_device_adapter_handle_t hDevices)
    {
        ctl_result_t Result = CTL_RESULT_SUCCESS;
        ze_device_handle_t Ze_device;
        ze_device_module_properties_t ZemoduleProperties;
        HINSTANCE hLevel0Loader = NULL;

        Result = ctlGetZeDevice(hDevices, &Ze_device, &(void \*)hLevel0Loader);
        if (CTL_RESULT_SUCCESS == Result && Ze_device != NULL)
        {
            std::cout << "Success: ctlDevice = " << hDevices << " ze_device = " << Ze_device << std::endl;
        }
        else
        {
            std::cout << "Error: Not able to get ze_device!\n";
        }

        // Try to get a level0 function using getprocaddress()
        if (hLevel0Loader && Ze_device)
        {
            ze_pfnDeviceGetModuleProperties_t pfnDeviceGetModuleProperties = (ze_pfnDeviceGetModuleProperties_t)GetProcAddress(hLevel0Loader, "zeDeviceGetModuleProperties");
            if (pfnDeviceGetModuleProperties)
            {
                std::cout << "Success: Obtained level0 zeDeviceGetModuleProperties "
                             "function\n";

                if (pfnDeviceGetModuleProperties(Ze_device, &ZemoduleProperties) == ZE_RESULT_SUCCESS)
                {
                    std::cout << "zemoduleProperties::spirvVersionSupported = " << ZemoduleProperties.spirvVersionSupported << std::endl;
                }
                else
                {
                    std::cout << "pfnDeviceGetModuleProperties() returned failure\n";
                }
            }
            else
            {
                std::cout << "Error: Not able to get level0 loader function\n";
            }
        }
        else
        {
            std::cout << "Error: Not able to get level0 instance\n";
        }
        
        free_memory(...)
        
        return Result;
    }                 
    
	
Refer samples for example code snippets of various API's

