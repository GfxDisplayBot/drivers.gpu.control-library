


==============
 Introduction
==============

Objective
---------

The objective of the Intel Graphics Control Library ( IGCL ) Application Programming Interface (API) is to provide a generic way to control various system level SW driver parameters and HW resources.
Its programming interface can be tailored to any device needs.
IGCL is meant to be a high level API for all control aspects of hardware, primarily graphics at this point.
This is a replacement of legacy CUISDK. It will allow global control and tweaking of display, media & 3D capabilities. It know how to talk to UMD, KMD and is expected to be multi-GPU and OS friendly.



.. image:: ../images/control_api_sw_stack.png

The API is intended for providing explicit controls needed by higher-level runtime APIs and libraries.
While initially influenced by GPU architecture, the Control APIs are designed to be supportable across different architectures.

Display
-------

The display set of API's help with

  - Graphics adapter enumeration & properties
  - Graphics output enumeration & properties
  - Specific functions to control various display pipeline capabilities like color, scaling, unique configurations, sharpness etc.

See the ref `display-programming-guide` for more details.

Media
-----

The media set of API's help with

  - Video post processing color feature control, such as color controls and skin tone enhancement.
  - Video post processing quality feature control, such as noise reduction, sharpness and contrast enhancement.

See the ref `media-programming-guide` for more details.

Level0 Handling
---------------

Control API has an instance of Level0 driver internally which allows it to talk to Level0 driver as and when required. It will provide an API which allow an application vendor to know of the Level0 device to talk to which corresponds to the control API device handle. 

Note: To test the sample along with level0, please ensure that the level0 binaries (primarily ze_loader.dll & ze_intel_gpu64.dll) are in a path accessible by the sample.

By default, only administrator users have permissions to perform control operations on resources.
Most queries are available to any user with the exception of those that could be used for side-channel attacks.
The systems administrator can tighten/relax the default permissions.

============
Fundamentals
============

The following section provides fundamentals of the API design.
For more detailed information, refer to the programming guides and detailed specification pages.

Header files can be found at: https://github.com/intel-innersource/drivers.gpu.control-api

Terminology
-----------

This specification uses key words based on `RFC2119 <https://www.ietf.org/rfc/rfc2119.txt>`__ to indicate requirement level.
In particular, the following words are used to describe the actions of an implementation of this specification:

  - **May** - the word *may*, or the adjective *optional*, mean that conforming implementations are permitted to, but need not behave as described.
  - **Should** - the word *should*, or the adjective *recommended*, mean that there could be reasons for an implementations to deviate from the behavior described, but that such deviation should be avoided.
  - **Must** - the word *must*, or the term *required* or *shall*, mean that the behavior described is an absolute requirement of the specification.

Naming Convention
-----------------

The following naming conventions must be followed:

  - All functions must be prefixed with `ctl`
  - All functions must use camel case `ctlObjectAction` convention
  - All macros must use all caps `CTL_NAME` convention
  - All structures, enumerations and other types must follow `ctl_name_t` snake case convention
  - All structure members and function parameters must use camel case convention
  - All enumerator values must use all caps `CTL_ENUM_ETOR_NAME` convention
  - All handle types must end with `handle_t`
  - All descriptor structures must end with `desc_t`
  - All property structures must end with `properties_t`
  - All flag enumerations must end with `flags_t`


The following coding conventions must be followed:

  - All interface structures must be derived from _base_interface_t
  - All function input parameters must precede output parameters
  - All functions must return :ref:`ctl-result-t`

Versioning
----------

There are multiple versions that should be used by the application to determine compatibility:


**API Version** - this is the version of the API supported by the device.

  - This is typically used to determine if the device supports the minimum set of APIs required by the application
  - There is a single 32-bit value that represents an entire collection of APIs
  - The value is encoded with 16-bit Major and 16-bit Minor parts
  - Major version increment consist of modified functionality, including deprecate features, and may break backwards-compatibility
  - Minor version increment consist of additional functionality, including promoted extensions, and must retain backwards-compatibility
  - The value is determined from calling :ref:`ctlInit`\()  
  - In addition to API version, each call will typically have a version field  in the interface structure.

  **Nonpointer structs**

  - A struct passed in as a non-pointer variable should not add new variables which can change the struct size.
  - They can change reserved fields aong with the comment of which structure & API version supports it
  - Implementation code should increment the struct specific max supported version.
  - If new fields are added, struct name should precede with an incrementing number and new function interface should be provided which accepts the new structure.
  - If new fields are added, the new function name should precede with an incrementing number. E.g. SetParameterX2([in] handle, [in] struct ctl_param_x2_t)
  - Caller should always fill the struct size and version fields properly as supported by released API spec

  **Pointer struct**

  - A struct passed in as pointer variable can add new variables to it
  - They can change reserved fields but should provide the new struct definition separately.    
  - Implementation code should increment the struct specific max supported version.
  - Caller should always fill the struct size and version fields properly as supported by released API spec.

  **API versioning between multiple driver installations**

  - Due to various reasons there can be more than one major version of the control API implementation in the system.
  - The default wrapper implementation provided knows how to select the right major version of the implementation (DLL).
  - Caller should always pass in the version they are coding for and the :ref:`ctlInit`\() call will return back with the implementation's APIs.
  - The value returned will be the API version supported by the device and known by the driver.
  - Caller shall never try to call an interface which the implementation doesn't have. If caller is using the provided wrapper, this will be taken caller
    automatically as wrapper won't find the new interface and will return failure.
  - Figure below describes a flow where three different implementation get into the system and how the behavior will be
  - Initially 1.1 DLL is there in the system from driver of say GPU2 HW.
  - Later user plugs in GPU1 and installs a driver which provides API DLL's having version 1.2 and 2.0.
  - Now in the system two DLL's will be kept each being the latest of their respective major versions, i.e. here 2.0 and 1.2.
  - Various types of applications negotiate the interface as shown in the top part of the figure.
  - In the System32 folder only the latest version of the DLL will reside.Even if user downgrades the graphics driver , the newer version in System32 will not be downgraded.
  - The dll packaged with the graphics driver will be copied in to the respective driver store.But the System32 folder will only have the latest version of the dll.
      
.. image:: ../images/control_api_version_management.png



**Driver Version** - this is the version of the driver installed in the system.

  - This is typically used to mitigate driver implementation issues for a feature
  - The value encoding is vendor-specific but must be monotonically increasing
  - The value is determined from calling :ref:`ctlGetDeviceProperties`

Error Handling
--------------

The following design philosophies are adopted in order to reduce Host-side overhead:

  - By default, the Control API implementation may not perform any form of detailed parameter validation

    + This should be handled by validation layer(s)

  - By default, Control API won't provide any protection against the following:

    + Invalid API programming
    + Invalid function arguments
    + Function infinite loops or recursions
    + Synchronization primitive deadlocks
    + Non-visible memory access by the Host or device
    + Non-resident memory access by the device

  - The Control API implementation is **not** required to perform API validation of any kind

    + The driver should ensure well-behaved applications are not burdened with the overhead needed for non-behaving applications
    + Unless otherwise specified, the driver behavior is undefined when APIs are improperly used
    + For debug purposes, API validation can be enabled via the loader's validation layer(s)

  - All API functions return :ref:`ctl-result-t`

    + This enumeration contains error codes for the Control APIs
    + This allows for a consistent pattern on the application side for catching errors
                                                                                    
Multi-threading and Concurrency
-------------------------------

The following design philosophies are adopted in order to maximize Host thread concurrency:

  - APIs are free-threaded when the device's object handle is different.

    + the Control API should avoid thread-locks for these API calls

  - APIs are not thread-safe when the device's object handle is the same, except when explicitly noted.

    + the application must ensure multiple threads do not enter an API when the handle is the same

  - APIs are not thread-safe with other APIs that use the same driver's object handle

    + the application must ensure multiple threads do not enter these APIs when the handle is the same

  - APIs do not support reference counting of handles.

    + the application must track ownership and explicitly free handles and memory
    + the application must ensure that all driver objects and memory are no longer in-use by the device before freeing; otherwise the Host or device may fault
    + no implicit garabage collection is supported by the driver

  - APIs can impact system configuration and it's application job to ensure it listens to system events provided by OS and provide parameters in sync with current system state
  
In general, the API is designed to be free-threaded rather than thread-safe.
This provides multi-threaded applications with complete control over both threading and locks.
This also eliminates unnecessary implementation overhead for single threaded applications and/or very low latency usages.

An application is in direct control over all Host thread creation and usage.
The driver should never implicitly create threads.
If there is a need for an implementation to use a background thread, then that thread should be created and provided by the application.

Given the system wide impact of these API's caller should take care of the possibility of another application changing the state using these or OS API's.
Caller shall register with OS events to know of system configuration changes which might impact the API's they are interested in and update it's internal state accordingly.

Each API function must document details on the multi-threading requirements for that call.

    
Application Binary Interface
----------------------------

The Control APIs in C are provided to applications by a shared wrapper helper file cApiWrapper.cpp.
C/C++ applications must include "control_api.h" and use the wrapper while calling the API's.
The wrapper will internally load the required implementation and call respective DLL exported functions.
With this application is tightly coupled with the DLL though.Wrapper approach helps with better control on control API DLL's update and version management.

The implementation of these libraries must use the default Application Binary Interface (ABI) of the standard C compiler for the platform.
An ABI in this context means the size, alignment, and layout of C data types; the procedure calling convention;
and the naming convention for shared library symbols corresponding to C functions. The ABI is backward-compatible
for API minor version increments such as adding new functions, appending new enumerators, and using reserved
bits in bitfields. ABI is not guaranteed to be backward-compatible for API major version increments such as
modifying existing function signatures and structures, removing functions and structures, etc.
